#!/usr/bin/env bash

./deps jq xxd php awk perl

function lines.json() {

	# Function to convert a list of items into a JSON array
	convert_to_json_array() {
		jq -R -s -c 'split("\n") | map(select(length > 0) | gsub("^\\s+|\\s+$"; ""))' <<< "$1"
	}

	# Function to handle JSON string input
	handle_json_string() {
		jq -s -c '.' <<< "$1"
	}

	# Check if the input is a JSON string or a list of items
	if echo -n "$1" | jq empty 2>/dev/null; then
		handle_json_string "$1"
	else
		convert_to_json_array "$1"
	fi
	
}

function items.index() {

	local input
	local index
	local json_array
	local output
	local start
	local end

	input=$(cat)
	index="$1" && shift
	json_array=$(echo -n "$1" | sed 's/ /", "/g; s/^/["/; s/$/"]/')
	
	output=""
	if [[ -z "$index" ]]; then
		# No index given, return all items
		output=$(echo -n "$json_array" | jq -r '.[]')
	else
		IFS=',' read -ra indices <<< "$index"

		for idx in "${indices[@]}"; do
			if [[ "$idx" =~ ^[0-9]+$ ]]; then
				# Single index given
				output+=$(echo -n "$json_array" | jq -r --argjson n "$idx" '.[$n]')$'\n'
			elif [[ "$idx" =~ ^[0-9]+-[0-9]+$ ]]; then
				# Range of indices given
				start=$(echo -n "$idx" | cut -d'-' -f1)
				end=$(echo -n "$idx" | cut -d'-' -f2)
				output+=$(echo -n "$json_array" | jq -r --argjson start "$start" --argjson end "$end" '.['"$start"':'"$end"'+1][]')$'\n'
			else
				echo -n "Invalid index format: $idx"
				exit 1
			fi
		done

		# Trim the trailing newline from the final output
		echo "${output%"${output##*[![:space:]]}"}"
	fi
}

function lines.index() {

	local index="$1" && shift
	local lines
	lines=$(echo -n "$1" | awk '{$1=$1;print}' | jq -R -s -c 'split("\n") | map(select(length > 0))')

	output=""
	if [[ -z "$index" ]]; then
		# No index given, return all lines
		output=$(echo -n "$lines" | jq -r '.[]' | codec newlines.decode)
	else
		IFS=',' read -ra indices <<< "$index"

		for idx in "${indices[@]}"; do
			reverse_flag=false
			if [[ "$idx" =~ ^- ]]; then
				reverse_flag=true
				idx="${idx#-}"
				lines=$(echo -n "$lines" | jq 'reverse')
			fi

			if [[ "$idx" =~ ^[0-9]+$ ]]; then
				output+=$(echo -n "$lines" | jq -r --argjson n "$idx" '.[$n]')$'\n'
			elif [[ "$idx" =~ ^[0-9]+-[0-9]+$ ]]; then
				start=$(echo -n "$idx" | cut -d'-' -f1)
				end=$(echo -n "$idx" | cut -d'-' -f2)
				output+=$(echo -n "$lines" | jq -r --argjson start "$start" --argjson end "$end" '.['"$start"':'"$end"'+1][]')$'\n'
			else
				echo -n "Invalid index format: $idx"
				exit 1
			fi

			if $reverse_flag; then
				lines=$(echo -n "$lines" | jq 'reverse')
			fi
		done

		# Trim the trailing newline from the final output
		echo "${output%"${output##*[![:space:]]}"}"
	fi
}

function item.raw() {
	jq -r <<< "$1"
}

function lines.markdown() {
	echo "${1//$'\n'/$'  \n'}"
}

function lines.items() {
	echo "$1" | awk '{$1=$1;print}' | jq -R -s -c 'split("\n") | map(select(length > 0) | @json) | join(" ")' | sed 's/\\\"/\"/g' | sed 's/^"//;s/"$//'
}

function text.filesafe() {
	sed 's/ /-/g; s/[^a-zA-Z0-9._-]//g' <<< "$1"
}

function json.encode() {
	jq -s -R -r @json <<< "$1"
}

function json.decode() {
	jq -r . <<< "$1"
}

function newlines.encode() {
	while IFS= read -r line || [[ -n "$line" ]]; do
		printf '%s\\n' "$line"
	done <<< "$1"
}

function newlines.decode() {
	echo -e "$1"
}

function url.encode() {
	jq -s -R -r @uri <<< "$1"
}

function url.decode() {
	perl -pe 'chomp; s/%([0-9a-f]{2})/sprintf("%s", pack("H2",$1))/eig' <<< "$1"
}

function form-data.encode() {
	jq -r 'to_entries | map("\(.key)=\(.value|@uri)") | join("&")' <<< "$1"
}

function form-data.decode() {

	IFS='&' read -ra key_value_pairs <<< "$1"
	
	json_object="{"
	for key_value_pair in "${key_value_pairs[@]}"; do
		IFS='=' read -r key value <<< "$key_value_pair"
		
		# Decode the key and value from URL encoding
		decoded_key=$(echo -e "$(sed 's/+/ /g;s/%\(..\)/\\x\1/g' <<< "$key")")
		decoded_value=$(echo -e "$(sed 's/+/ /g;s/%\(..\)/\\x\1/g' <<< "$value")")
		
		# Ensure keys are URI encoded for JSON keys
		json_key=$(jq -Rr @uri <<<"$decoded_key")
		
		# Check if decoded_value is a JSON array or object
		if [[ $decoded_value == \{* ]] || [[ $decoded_value == \[* ]]; then
			# It's a JSON array or object, add it directly
			json_object+="\"$json_key\":$decoded_value,"
		else
			# It's a regular string, format it for JSON
			json_object+="\"$json_key\":$(jq -Rr @json <<<"$decoded_value"),"
		fi
	done
	json_object="${json_object%,}}"
	
	jq -cM . <<< "$json_object"
}

function base64.encode() {
	perl -MMIME::Base64 -ne 'print encode_base64($_)' <<< "$1"
}

function base64.decode() {
	perl -MMIME::Base64 -ne 'print decode_base64($_)' <<< "$1"
}

function hex.encode() {
	xxd -ps <<< "$1"
}

function hex.decode() {
	xxd -r -p <<< "$1"
}

function html_encode() { # shellcheck disable=SC2016
	php -R 'echo htmlentities($argn, ENT_QUOTES|ENT_HTML5) . "\n";' <<< "$1"
}

function html.decode() { # shellcheck disable=SC2016
	php -R 'echo html_entity_decode($argn, ENT_QUOTES|ENT_HTML5) . "\n";' <<< "$1"
}

function main() {
	
	local command=$1 && shift
	
	[[ $(type -t "$command") != "function" ]] && echo "Invalid command: $command" && exit 1

	"$command" "$@"

}

run_script "$@"
