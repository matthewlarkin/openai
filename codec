#!/usr/bin/env bash

cd "$(dirname "$0")" && source .lib/barerc || exit 1

deps jq xxd php awk perl

function hash() {
	# shellcheck disable=2005
    echo "$(php -r "
\$password = '$1';
\$hash = password_hash(\$password, PASSWORD_ARGON2ID, ['time_cost' => 3, 'memory_cost' => 65540, 'threads' => 4]);
echo \$hash;
")"
}

function hash.verify() {
	# shellcheck disable=2005
    echo "$(php -r "
\$password = '$1';
\$hash = '$2';
if (password_verify(\$password, \$hash)) {
    echo 'true';
} else {
    echo 'false';
}
")"
}

function lines.json() {

	# Function to convert a list of items into a JSON array
	convert_to_json_array() {
		jq -R -s -c 'split("\n") | map(select(length > 0) | gsub("^\\s+|\\s+$"; ""))' <<< "$1"
	}

	# Function to handle JSON string input
	handle_json_string() {
		jq -s -c '.' <<< "$1"
	}

	# Check if the input is a JSON string or a list of items
	if echo -n "$1" | jq empty 2>/dev/null; then
		handle_json_string "$1"
	else
		convert_to_json_array "$1"
	fi
	
}

function items.index() {

	local input
	local index
	local json_array
	local output
	local start
	local end

	input=$(cat)
	index="$1" && shift
	json_array=$(echo -n "$1" | sed 's/ /", "/g; s/^/["/; s/$/"]/')
	
	output=""
	if [[ -z "$index" ]]; then
		# No index given, return all items
		output=$(echo -n "$json_array" | jq -r '.[]')
	else
		IFS=',' read -ra indices <<< "$index"

		for idx in "${indices[@]}"; do
			if [[ "$idx" =~ ^[0-9]+$ ]]; then
				# Single index given
				output+=$(echo -n "$json_array" | jq -r --argjson n "$idx" '.[$n]')$'\n'
			elif [[ "$idx" =~ ^[0-9]+-[0-9]+$ ]]; then
				# Range of indices given
				start=$(echo -n "$idx" | cut -d'-' -f1)
				end=$(echo -n "$idx" | cut -d'-' -f2)
				output+=$(echo -n "$json_array" | jq -r --argjson start "$start" --argjson end "$end" '.['"$start"':'"$end"'+1][]')$'\n'
			else
				echo -n "Invalid index format: $idx"
				exit 1
			fi
		done

		# Trim the trailing newline from the final output
		echo "${output%"${output##*[![:space:]]}"}"
	fi
}

function lines.index() {

	local index="$1" && shift
	local lines
	lines=$(echo -n "$1" | awk '{$1=$1;print}' | jq -R -s -c 'split("\n") | map(select(length > 0))')

	output=""
	if [[ -z "$index" ]]; then
		# No index given, return all lines
		output=$(echo -n "$lines" | jq -r '.[]' | codec newlines.decode)
	else
		IFS=',' read -ra indices <<< "$index"

		for idx in "${indices[@]}"; do
			reverse_flag=false
			if [[ "$idx" =~ ^- ]]; then
				reverse_flag=true
				idx="${idx#-}"
				lines=$(echo -n "$lines" | jq 'reverse')
			fi

			if [[ "$idx" =~ ^[0-9]+$ ]]; then
				output+=$(echo -n "$lines" | jq -r --argjson n "$idx" '.[$n]')$'\n'
			elif [[ "$idx" =~ ^[0-9]+-[0-9]+$ ]]; then
				start=$(echo -n "$idx" | cut -d'-' -f1)
				end=$(echo -n "$idx" | cut -d'-' -f2)
				output+=$(echo -n "$lines" | jq -r --argjson start "$start" --argjson end "$end" '.['"$start"':'"$end"'+1][]')$'\n'
			else
				echo -n "Invalid index format: $idx"
				exit 1
			fi

			if $reverse_flag; then
				lines=$(echo -n "$lines" | jq 'reverse')
			fi
		done

		# Trim the trailing newline from the final output
		echo "${output%"${output##*[![:space:]]}"}"
	fi
}

function item.raw() {
	jq -r <<< "$1"
}

function lines.markdown() {
	echo "${1//$'\n'/$'  \n'}"
}

function lines.items() {
	echo "$1" | awk '{$1=$1;print}' | jq -R -s -c 'split("\n") | map(select(length > 0) | @json) | join(" ")' | sed 's/\\\"/\"/g' | sed 's/^"//;s/"$//'
}

function text.filesafe() {
	sed 's/ /-/g; s/[^a-zA-Z0-9._-]//g' <<< "$1"
}

function json.encode() {
	jq -s -R -r @json <<< "$1"
}

function json.decode() {
	jq -r . <<< "$1"
}

function newlines.encode() {
	while IFS= read -r line || [[ -n "$line" ]]; do
		printf '%s\\n' "$line"
	done <<< "$1"
}

function newlines.decode() {
	echo -e "$1"
}

function url.encode() {
	echo -n "$1" | jq -s -R -r @uri
}

function url.decode() {
	perl -pe 'chomp; s/%([0-9a-f]{2})/sprintf("%s", pack("H2",$1))/eig' <<< "$1"
	echo ""
}

function form-data.encode() {
    input_string="$1"
    python3 - <<END
import json
import urllib.parse

def flatten(d, parent_key=''):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}[{k}]" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten(v, new_key).items())
        elif isinstance(v, list):
            for i, sub_v in enumerate(v):
                items.extend(flatten({str(i): sub_v}, new_key).items())
        else:
            items.append((new_key, v))
    return dict(items)

# Load JSON from input string
input_string = """$input_string"""
json_obj = json.loads(input_string)

# Flatten the JSON
flat_json = flatten(json_obj)

# Encode as form-data
encoded = "&".join(f"{k}={urllib.parse.quote_plus(str(v))}" for k, v in flat_json.items())
print(encoded)
END
}


function form-data.decode() {

    input_string="$1"

    # Use Python to parse the input and convert it to JSON
    python3 - <<END
import urllib.parse
import json
import re

# Input string from Bash
input_string = "$input_string"

# Parse the query string
parsed = urllib.parse.parse_qsl(input_string)

# Initialize a dictionary to hold the final JSON structure
json_obj = {}

# Function to set nested keys in the dictionary
def set_nested_value(d, keys, value):
    for key in keys[:-1]:
        if key.isdigit():
            key = int(key)
        if isinstance(d, list) and isinstance(key, int):
            while len(d) <= key:
                d.append({})
            d = d[key]
        else:
            d = d.setdefault(key, {})
    final_key = keys[-1]
    if final_key.isdigit():
        final_key = int(final_key)
    if isinstance(d, list) and isinstance(final_key, int):
        while len(d) <= final_key:
            d.append({})
        d[final_key] = value
    else:
        d[final_key] = value

# Loop through the parsed key-value pairs and structure them into nested JSON
for key, value in parsed:
    # Split the key into parts based on bracket notation
    parts = re.findall(r'\w+', key)
    set_nested_value(json_obj, parts, value)

# Convert dictionaries with integer keys into lists
def convert_to_list(obj):
    if isinstance(obj, dict):
        keys = obj.keys()
        if all(isinstance(k, int) for k in keys):
            max_index = max(keys)
            lst = [obj.get(i, {}) for i in range(max_index + 1)]
            return [convert_to_list(v) for v in lst]
        else:
            return {k: convert_to_list(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_to_list(v) for v in obj]
    else:
        return obj

# Convert and print the final JSON output
final_json = convert_to_list(json_obj)
print(json.dumps(final_json, indent=2))
END
}




function base64.encode() {
	perl -MMIME::Base64 -ne 'print encode_base64($_)' <<< "$1"
}

function base64.decode() {
	perl -MMIME::Base64 -ne 'print decode_base64($_)' <<< "$1"
}

function hex.encode() {
	xxd -ps <<< "$1"
}

function hex.decode() {
	xxd -r -p <<< "$1"
}

function html_encode() { # shellcheck disable=SC2016
	php -R 'echo htmlentities($argn, ENT_QUOTES|ENT_HTML5) . "\n";' <<< "$1"
}

function html.decode() { # shellcheck disable=SC2016
	php -R 'echo html_entity_decode($argn, ENT_QUOTES|ENT_HTML5) . "\n";' <<< "$1"
}

function main() {

    	# Use mapfile to read function names into an array
	mapfile -t function_names < <(declare -F | awk '{print $3}')
	
	# Function to check if a command is a valid function
	is_valid_function() {
		local command=$1
		for func in "${function_names[@]}"; do
			if [[ "$func" == "$command" ]]; then
				return 0
			fi
		done
		return 1
	}
	
	# Initialize variables
	command=""
	source_material=""
	
	# Loop through arguments to find the command and source material
	while [[ $# -gt 0 ]]; do
		if is_valid_function "$1"; then
			command="$1"
		else
			source_material="$1"
		fi
		shift
	done
	
	# Check if a valid command was found
	if [[ -z "$command" ]]; then
		echo "Invalid command: No valid function found in arguments"
		exit 1
	fi
	
	# Check if source material is provided
	if [[ -z "$source_material" ]]; then
		echo "No source material provided"
		exit 1
	fi
	
	# Call the function with the source material
	"$command" "$source_material"
}
	
# Run the main function with all script arguments
run_script "$@"