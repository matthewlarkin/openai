#!/usr/bin/env bash

cd "$(dirname "$0")" && source .lib/barerc || exit 1

# Capture input if piped
[[ -t 0 ]] || input=$(cat)

# set system timezone temporarily
TZ="$BARE_TIMEZONE"

# Determine the correct date command based on the operating system
if [[ "$OS" == "macOS" ]]; then
    DATE_CMD="gdate"
else
    DATE_CMD="date"
fi

# Initialize empty array for remaining arguments
remaining_args=()

date_format="%Y-%m-%d %H:%M:%S"
input_format="%Y-%m-%d %H:%M:%S"
offset=""

# Process arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    as|-F|--format|--formatted) # can't do -f here since native date relies on this
        custom_format=1 && shift
        read -r -a format_parts <<< "$1"  # Allows us to handle date and time dynamically as parts
        date_format=""
        for part in "${format_parts[@]}"; do
            case $part in

                'U') date_format+="%s " ;;  # 1628841600

                'Y-M-D') date_format+="%Y-%m-%d " ;;  # 2024-08-13
                'M-D-Y') date_format+="%m-%d-%Y " ;;  # 08-13-2024
                'M/D/Y') date_format+="%m/%d/%Y " ;;  # 08/13/2024

                # Additional formats to handle leading zeroes
                'Y-m-d') date_format+="%Y-%-m-%-d " ;;  # 2024-8-13
                'y-m-d') date_format+="%y-%-m-%-d " ;;  # 24-8-13
                'd-m-Y') date_format+="%-d-%-m-%Y " ;;  # 13-8-2024
                'm-d-Y') date_format+="%-m-%-d-%Y " ;;  # 8-13-2024
                'd/m/Y') date_format+="%-d/%-m/%Y " ;;  # 13/8/2024
                'm/d/Y') date_format+="%-m/%-d/%Y " ;;  # 8/13/2024

                # times
                'H:M:S'|'H:m:s') date_format+="%H:%M:%S " ;; # 14:30:00
                'H:M'|'H:m') date_format+="%H:%M " ;; # 14:30
                'h:m:s'|'h:M:S'|'h:M:s'|'h:m:S') date_format+="%-I:%M:%S %p " ;; # 2:30:00 PM
                'h:m'|'h:M') date_format+="%-I:%M %p " ;; # 2:30 PM

                *) echo "Invalid format" && exit 1 ;;

            esac
        done
        date_format="${date_format% }"  # Remove trailing space
        shift
        ;;
    --offset)
        shift
        offset="$1"
        shift
        ;;
    *)
        remaining_args+=("$1")
        shift
        ;;
  esac
done

# Set the remaining arguments
set -- "${remaining_args[@]}"

# If no arguments or input, default to today's date
[[ -z $input && $# -eq 0 ]] && input=$(TZ=$TZ gdate +"%Y-%m-%d %H:%M:%S")
[[ -z $input ]] && input="$1"

# Detect the operating system
os_type=$(uname)

# Get today's date in yyyy-mm-dd format
if [ "$os_type" = "Darwin" ] && command -v gdate &> /dev/null; then
    today=$(TZ=$TZ gdate +"%Y-%m-%d")
else
    today=$(TZ=$TZ date +"%Y-%m-%d")
fi

# condition yyyy-mm-dd
if [[ $(validate date "$input" --format 'Y-m-d') == 'true' ]]; then
    input="$input 00:00:00"
# yyyy-mm-dd hh:mm:ss
elif [[ $(validate date "$input" --format 'Y-m-d hh:mm:ss') == 'true' ]]; then
    # input is already in the correct format
    :
# yyyy-mm-dd hh:mm
elif [[ $(validate date "$input" --format 'Y-m-d hh:mm') == 'true' ]]; then
    input="$input:00"
# hh:mm
elif [[ $(validate date "$input" --format 'hh:mm') == 'true' ]]; then
    input="$today $input:00"
# hh:mm:ss
elif [[ $(validate date "$input" --format 'hh:mm:ss') == 'true' ]]; then
    input="$today $input"
# yyyy-mm-ddThh:mm:ssZ
elif [[ $(validate date "$input" --format 'Y-m-d\Thh:mm:ss\Z') == 'true' ]]; then
    :
fi

# Validate the date and time
if [[ $# -eq 1 ]]; then
    if [ "$OS" = "macOS" ]; then
        gdate -d "$input_format" "$input" &> /dev/null && valid_date="true"
    else
        gdate -d "$input" &> /dev/null && valid_date="true"
    fi
fi

# Format and print the date using the specified format, or default to standard
if [[ $custom_format == 1 ]]; then
    if [[ "$OS" == "macOS" ]]; then
        formatted_date=$(TZ=$TZ gdate -d "$input" +"$date_format")
    else
        formatted_date=$(TZ=$TZ gdate -d "$input" +"$date_format")
    fi
    echo "$formatted_date" && exit 0
else
    TZ=$TZ /bin/date "$@"
fi